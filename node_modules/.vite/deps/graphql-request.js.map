{
  "version": 3,
  "sources": ["../../graphql-request/src/legacy/classes/ClientError.ts", "../../graphql-request/src/lib/prelude.ts", "../../graphql-request/src/legacy/functions/batchRequests.ts", "../../graphql-request/src/legacy/functions/rawRequest.ts", "../../graphql-request/src/lib/http.ts", "../../graphql-request/src/legacy/lib/graphql.ts", "../../graphql-request/src/legacy/helpers/analyzeDocument.ts", "../../graphql-request/src/legacy/helpers/defaultJsonSerializer.ts", "../../graphql-request/src/legacy/helpers/runRequest.ts", "../../graphql-request/src/legacy/classes/GraphQLClient.ts", "../../graphql-request/src/legacy/functions/request.ts", "../../graphql-request/src/legacy/functions/gql.ts", "../../graphql-request/src/entrypoints/main.ts"],
  "sourcesContent": ["import type { GraphQLRequestContext, GraphQLResponse } from '../helpers/types.js'\n\nexport class ClientError extends Error {\n  public response: GraphQLResponse\n  public request: GraphQLRequestContext\n\n  constructor(response: GraphQLResponse, request: GraphQLRequestContext) {\n    const message = `${ClientError.extractMessage(response)}: ${\n      JSON.stringify({\n        response,\n        request,\n      })\n    }`\n\n    super(message)\n\n    Object.setPrototypeOf(this, ClientError.prototype)\n\n    this.response = response\n    this.request = request\n\n    // this is needed as Safari doesn't support .captureStackTrace\n    if (typeof Error.captureStackTrace === `function`) {\n      Error.captureStackTrace(this, ClientError)\n    }\n  }\n\n  private static extractMessage(response: GraphQLResponse): string {\n    return response.errors?.[0]?.message ?? `GraphQL Error (Code: ${String(response.status)})`\n  }\n}\n", "/* eslint-disable */\nexport type RemoveIndex<T> = {\n  [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K]\n}\n\nexport const uppercase = <S extends string>(str: S): Uppercase<S> => str.toUpperCase() as Uppercase<S>\n\nexport const callOrIdentity = <T>(value: MaybeLazy<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\nexport type MaybeLazy<T> = T | (() => T)\n\nexport const zip = <A, B>(a: A[], b: B[]): [A, B | undefined][] => a.map((k, i) => [k, b[i]])\n\nexport const HeadersInitToPlainObject = (headers?: HeadersInit): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n\n  if (headers instanceof Headers) {\n    oHeaders = HeadersInstanceToPlainObject(headers)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(([name, value]) => {\n      if (name && value !== undefined) {\n        oHeaders[name] = value\n      }\n    })\n  } else if (headers) {\n    oHeaders = headers\n  }\n\n  return oHeaders\n}\n\nexport const HeadersInstanceToPlainObject = (headers: Response['headers']): Record<string, string> => {\n  const o: Record<string, string> = {}\n  headers.forEach((v, k) => {\n    o[k] = v\n  })\n  return o\n}\n\nexport const tryCatch = <$Return, $Throw extends Error = Error>(\n  fn: () => $Return,\n): $Return extends Promise<any> ? Promise<Awaited<$Return> | $Throw> : $Return | $Throw => {\n  try {\n    const result = fn() as any\n    if (isPromiseLikeValue(result)) {\n      return result.catch((error) => {\n        return errorFromMaybeError(error)\n      }) as any\n    }\n    return result\n  } catch (error) {\n    return errorFromMaybeError(error) as any\n  }\n}\n\n/**\n * Ensure that the given value is an error and return it. If it is not an error than\n * wrap it in one, passing the given value as the error message.\n */\nexport const errorFromMaybeError = (maybeError: unknown): Error => {\n  if (maybeError instanceof Error) return maybeError\n  return new Error(String(maybeError))\n}\n\nexport const isPromiseLikeValue = (value: unknown): value is Promise<unknown> => {\n  return (\n    typeof value === `object`\n    && value !== null\n    && `then` in value\n    && typeof value.then === `function`\n    && `catch` in value\n    && typeof value.catch === `function`\n    && `finally` in value\n    && typeof value.finally === `function`\n  )\n}\n\nexport const casesExhausted = (value: never): never => {\n  throw new Error(`Unhandled case: ${String(value)}`)\n}\n\nexport const isPlainObject = (value: unknown): value is Record<string, unknown> => {\n  return typeof value === `object` && value !== null && !Array.isArray(value)\n}\n\nexport const entries = <T extends Record<string, any>>(obj: T) => Object.entries(obj) as [keyof T, T[keyof T]][]\n\nexport const values = <T extends Record<string, unknown>>(obj: T): T[keyof T][] => Object.values(obj) as T[keyof T][]\n\n// dprint-ignore\nexport type Exact<$Value, $Constraint> =\n  (\n    $Value extends unknown  ? $Constraint extends $Value   ?  {} extends $Value    ?  $Constraint :\n                                                                                      { [K in keyof $Value]: Exact<$Value[K], $Constraint[K]> } :\n                                                              $Constraint :\n                              never\n  )\n  | ($Value extends Narrowable ? $Value : never)\n\n// dprint-ignore\n// export type ExactObjectNonEmpty<$Value, $Constraint> =\n//   (\n//     $Value extends unknown  ? $Constraint extends $Value   ?  keyof $Value extends never  ? ({ 'TypeScript Error: You must supply at least one key.': true } & $Constraint)  :\n//                                                                                             { [K in keyof $Value]: Exact<$Value[K], $Constraint[K]> } :\n//                                                               $Constraint :\n//                               never\n//   )\n//   | ($Value extends Narrowable ? $Value : never)\n\nexport type Narrowable = string | number | bigint | boolean | []\n\nexport type Letter = LetterLower | LetterUpper\n\nexport type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\nexport type LetterLower =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'\nexport type LetterUpper =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z'\n\nexport type StringNonEmpty = `${Letter}${string}`\n\nexport type MaybeList<T> = T | T[]\n\nexport type NotEmptyObject<T> = keyof T extends never ? never : T\n\nexport type Values<T> = T[keyof T]\n\nexport type GetKeyOr<T, Key, Or> = Key extends keyof T ? T[Key] : Or\n\nexport type As<T, U> = U extends T ? U : never\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n\nexport type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never\n\n// TS4.0+\nexport type Push<T extends any[], V> = [...T, V]\n\n// TS4.1+\nexport type UnionToTuple<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? []\n  : Push<UnionToTuple<Exclude<T, L>>, L>\n\nexport type CountKeys<T> = keyof T extends never ? 0 : UnionToTuple<keyof T>['length']\nexport type IsMultipleKeys<T> = IsMultiple<CountKeys<T>>\nexport type IsMultiple<T> = T extends 0 ? false : T extends 1 ? false : true\n\nexport type ExcludeNull<T> = Exclude<T, null>\n\nexport const mapValues = <\n  $Obj extends Record<string, any>,\n  $Fn extends (value: $Obj[keyof $Obj], key: keyof $Obj) => any,\n>(\n  object: $Obj,\n  fn: $Fn,\n): Record<keyof $Obj, ReturnType<$Fn>> => {\n  return Object.fromEntries(\n    Object.entries(object).map(([key, value]) => {\n      return [key, fn(value, key)]\n    }),\n  ) as Record<keyof $Obj, ReturnType<$Fn>>\n}\n\nexport type SetProperty<$Obj extends object, $Prop extends keyof $Obj, $Type extends $Obj[$Prop]> =\n  & Omit<$Obj, $Prop>\n  & { [_ in $Prop]: $Type }\n\nexport const lowerCaseFirstLetter = (s: string) => {\n  return s.charAt(0).toLowerCase() + s.slice(1)\n}\n\nexport function assertArray(v: unknown): asserts v is unknown[] {\n  if (!Array.isArray(v)) throw new Error(`Expected array. Got: ${String(v)}`)\n}\n\nexport function assertObject(v: unknown): asserts v is object {\n  if (v === null || typeof v !== `object`) throw new Error(`Expected object. Got: ${String(v)}`)\n}\n\nexport type StringKeyof<T> = keyof T & string\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport const capitalizeFirstLetter = (string: string) => string.charAt(0).toUpperCase() + string.slice(1)\n\nexport type SomeAsyncFunction = (...args: unknown[]) => Promise<unknown>\n\nexport type SomeMaybeAsyncFunction = (...args: unknown[]) => MaybePromise<unknown>\n\nexport type Deferred<T> = {\n  promise: Promise<T>\n  isResolved: () => boolean\n  resolve: (value: T) => void\n  reject: (error: unknown) => void\n}\n\nexport const createDeferred = <$T>(options?: { strict?: boolean }): Deferred<$T> => {\n  let isResolved = false\n  let resolve: (value: $T) => void\n  let reject: (error: unknown) => void\n\n  const promise = new Promise<$T>(($resolve, $reject) => {\n    resolve = $resolve\n    reject = $reject\n  })\n\n  return {\n    promise,\n    isResolved: () => isResolved,\n    resolve: (value) => {\n      isResolved = true\n      if (options?.strict && isResolved) {\n        throw new Error(`Deferred is already resolved. Attempted to resolve with: ${JSON.stringify(value)}`)\n      }\n      resolve(value)\n    },\n    reject: (error) => reject(error),\n  }\n}\n\nexport const debug = (...args: any[]) => {\n  if (process.env[`DEBUG`]) {\n    console.log(...args)\n  }\n}\n\nexport const debugSub = (...args: any[]) => (...subArgs: any[]) => {\n  debug(...args, ...subArgs)\n}\n\nexport type PlusOneUpToTen<n extends number> = n extends 0 ? 1\n  : n extends 1 ? 2\n  : n extends 2 ? 3\n  : n extends 3 ? 4\n  : n extends 4 ? 5\n  : n extends 5 ? 6\n  : n extends 6 ? 7\n  : n extends 7 ? 8\n  : n extends 8 ? 9\n  : n extends 9 ? 10\n  : never\n\nexport type MinusOneUpToTen<n extends number> = n extends 10 ? 9\n  : n extends 9 ? 8\n  : n extends 8 ? 7\n  : n extends 7 ? 6\n  : n extends 6 ? 5\n  : n extends 5 ? 4\n  : n extends 4 ? 3\n  : n extends 3 ? 2\n  : n extends 2 ? 1\n  : n extends 1 ? 0\n  : never\n\nexport type findIndexForValue<value, list extends readonly [any, ...any[]]> = findIndexForValue_<value, list, 0>\ntype findIndexForValue_<value, list extends readonly [any, ...any[]], i extends number> = value extends list[i] ? i\n  : findIndexForValue_<value, list, PlusOneUpToTen<i>>\n\nexport type FindValueAfter<value, list extends readonly [any, ...any[]]> =\n  list[PlusOneUpToTen<findIndexForValue<value, list>>]\n\nexport type ValueOr<value, orValue> = value extends undefined ? orValue : value\n\nexport type FindValueAfterOr<value, list extends readonly [any, ...any[]], orValue> = ValueOr<\n  list[PlusOneUpToTen<findIndexForValue<value, list>>],\n  orValue\n>\n\nexport type GetLastValue<T extends readonly [any, ...any[]]> = T[MinusOneUpToTen<T['length']>]\n\nexport type IsLastValue<value, list extends readonly [any, ...any[]]> = value extends GetLastValue<list> ? true : false\n\nexport type Include<T, U> = T extends U ? T : never\n\nexport const partitionErrors = <T>(array: T[]): [Exclude<T, Error>[], Include<T, Error>[]] => {\n  const errors: Include<T, Error>[] = []\n  const values: Exclude<T, Error>[] = []\n  for (const item of array) {\n    if (item instanceof Error) {\n      errors.push(item as any)\n    } else {\n      values.push(item as any)\n    }\n  }\n  return [values, errors]\n}\n", "import { GraphQLClient } from '../classes/GraphQLClient.js'\nimport type { RequestDocument, Variables } from '../helpers/types.js'\n\nexport type BatchRequestDocument<V extends Variables = Variables> = {\n  document: RequestDocument\n  variables?: V\n}\n\nexport interface BatchRequestsOptions<V extends Variables = Variables> {\n  documents: BatchRequestDocument<V>[]\n  requestHeaders?: HeadersInit\n  signal?: RequestInit['signal']\n}\n\nexport interface BatchRequestsExtendedOptions<V extends Variables = Variables> extends BatchRequestsOptions<V> {\n  url: string\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: HeadersInit]\n  | [options: BatchRequestsExtendedOptions]\n\nexport const parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\n// dprint-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: HeadersInit): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\nexport type BatchResult = [Result, ...Result[]]\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\nexport const parseBatchRequestArgs = <V extends Variables = Variables>(\n  documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n  requestHeaders?: HeadersInit,\n): BatchRequestsOptions<V> => {\n  // eslint-disable-next-line\n  return (documentsOrOptions as BatchRequestsOptions<V>).documents\n    ? (documentsOrOptions as BatchRequestsOptions<V>)\n    : {\n      documents: documentsOrOptions as BatchRequestDocument<V>[],\n      requestHeaders: requestHeaders,\n      signal: undefined,\n    }\n}\n", "import { GraphQLClient } from '../classes/GraphQLClient.js'\nimport type {\n  GraphQLClientResponse,\n  RawRequestOptions,\n  Variables,\n  VariablesAndRequestHeadersArgs,\n} from '../helpers/types.js'\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<GraphQLClientResponse<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n// dprint-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<GraphQLClientResponse<T>>\n}\n\n// dprint-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\nexport const parseRawRequestExtendedArgs = <V extends Variables = Variables>(\n  urlOrOptions: string | RawRequestExtendedOptions<V>,\n  query?: string,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): RawRequestExtendedOptions<V> => {\n  const [variables, requestHeaders] = variablesAndRequestHeaders\n  return typeof urlOrOptions === `string`\n    ? ({\n      url: urlOrOptions,\n      query: query as string,\n      variables,\n      requestHeaders,\n      signal: undefined,\n    } as unknown as RawRequestExtendedOptions<V>)\n    : urlOrOptions\n}\n\nexport type RawRequestExtendedOptions<V extends Variables = Variables> = {\n  url: string\n} & RawRequestOptions<V>\n\nexport const parseRawRequestArgs = <V extends Variables = Variables>(\n  queryOrOptions: string | RawRequestOptions<V>,\n  variables?: V,\n  requestHeaders?: HeadersInit,\n): RawRequestOptions<V> => {\n  return (queryOrOptions as RawRequestOptions<V>).query\n    ? (queryOrOptions as RawRequestOptions<V>)\n    : ({\n      query: queryOrOptions as string,\n      variables: variables,\n      requestHeaders: requestHeaders,\n      signal: undefined,\n    } as unknown as RawRequestOptions<V>)\n}\n", "export const ACCEPT_HEADER = `Accept`\nexport const CONTENT_TYPE_HEADER = `Content-Type`\nexport const CONTENT_TYPE_JSON = `application/json`\nexport const CONTENT_TYPE_GQL = `application/graphql-response+json`\nexport const statusCodes = {\n  success: 200,\n}\n", "import { Kind } from 'graphql'\nimport { CONTENT_TYPE_GQL, CONTENT_TYPE_JSON } from '../../lib/http.js'\nimport { isPlainObject } from '../../lib/prelude.js'\n/**\n * Refactored imports from `graphql` to be more specific, this helps import only the required files (100KiB)\n * instead of the entire package (greater than 500KiB) where tree-shaking is not supported.\n * @see https://github.com/jasonkuhrt/graphql-request/pull/543\n */\nimport type { OperationDefinitionNode } from 'graphql'\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nexport const cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\nexport const isGraphQLContentType = (contentType: string) => {\n  const contentTypeLower = contentType.toLowerCase()\n\n  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON)\n}\n\nexport type GraphQLRequestResult = GraphQLRequestResultBatch | GraphQLRequestResultSingle\nexport type GraphQLRequestResultBatch = { _tag: 'Batch'; executionResults: GraphQLExecutionResultBatch }\nexport type GraphQLRequestResultSingle = { _tag: 'Single'; executionResult: GraphQLExecutionResultSingle }\n\nexport type GraphQLExecutionResult = GraphQLExecutionResultSingle | GraphQLExecutionResultBatch\nexport type GraphQLExecutionResultBatch = GraphQLExecutionResultSingle[]\nexport type GraphQLExecutionResultSingle = {\n  data: object | null | undefined\n  errors: undefined | object | object[]\n  extensions?: object\n}\n\nexport const parseGraphQLExecutionResult = (result: unknown): Error | GraphQLRequestResult => {\n  try {\n    if (Array.isArray(result)) {\n      return {\n        _tag: `Batch`,\n        executionResults: result.map(parseExecutionResult),\n      }\n    } else if (isPlainObject(result)) {\n      return {\n        _tag: `Single`,\n        executionResult: parseExecutionResult(result),\n      }\n    } else {\n      throw new Error(`Invalid execution result: result is not object or array. \\nGot:\\n${String(result)}`)\n    }\n  } catch (e) {\n    return e as Error\n  }\n}\n\n/**\n * Example result:\n *\n * ```\n * {\n *  \"data\": null,\n *  \"errors\": [{\n *    \"message\": \"custom error\",\n *    \"locations\": [{ \"line\": 2, \"column\": 3 }],\n *    \"path\": [\"playerNew\"]\n *  }]\n * }\n * ```\n */\nexport const parseExecutionResult = (result: unknown): GraphQLExecutionResultSingle => {\n  if (typeof result !== `object` || result === null) {\n    throw new Error(`Invalid execution result: result is not object`)\n  }\n\n  let errors = undefined\n  let data = undefined\n  let extensions = undefined\n\n  if (`errors` in result) {\n    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {\n      throw new Error(`Invalid execution result: errors is not plain object OR array`) // prettier-ignore\n    }\n    errors = result.errors\n  }\n\n  // todo add test coverage for case of null. @see https://github.com/jasonkuhrt/graphql-request/issues/739\n  if (`data` in result) {\n    if (!isPlainObject(result.data) && result.data !== null) {\n      throw new Error(`Invalid execution result: data is not plain object`) // prettier-ignore\n    }\n    data = result.data\n  }\n\n  if (`extensions` in result) {\n    if (!isPlainObject(result.extensions)) throw new Error(`Invalid execution result: extensions is not plain object`) // prettier-ignore\n    extensions = result.extensions\n  }\n\n  return {\n    data,\n    errors,\n    extensions,\n  }\n}\n\nexport const isRequestResultHaveErrors = (result: GraphQLRequestResult) =>\n  result._tag === `Batch`\n    ? result.executionResults.some(isExecutionResultHaveErrors)\n    : isExecutionResultHaveErrors(result.executionResult)\n\nexport const isExecutionResultHaveErrors = (result: GraphQLExecutionResultSingle) =>\n  Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors)\n\nexport const isOperationDefinitionNode = (definition: unknown): definition is OperationDefinitionNode => {\n  return (\n    typeof definition === `object`\n    && definition !== null\n    && `kind` in definition\n    && definition.kind === Kind.OPERATION_DEFINITION\n  )\n}\n", "import { tryCatch } from '../../lib/prelude.js'\nimport { isOperationDefinitionNode } from '../lib/graphql.js'\nimport type { RequestDocument } from './types.js'\n/**\n * Refactored imports from `graphql` to be more specific, this helps import only the required files (100KiB)\n * instead of the entire package (greater than 500KiB) where tree-shaking is not supported.\n * @see https://github.com/jasonkuhrt/graphql-request/pull/543\n */\nimport { type DocumentNode, OperationTypeNode } from 'graphql'\nimport { parse } from 'graphql'\nimport { print } from 'graphql'\n\n/**\n * helpers\n */\n\nconst extractOperationName = (document: DocumentNode): string | undefined => {\n  let operationName = undefined\n\n  const defs = document.definitions.filter(isOperationDefinitionNode)\n\n  if (defs.length === 1) {\n    operationName = defs[0]!.name?.value\n  }\n\n  return operationName\n}\n\nconst extractIsMutation = (document: DocumentNode): boolean => {\n  let isMutation = false\n\n  const defs = document.definitions.filter(isOperationDefinitionNode)\n\n  if (defs.length === 1) {\n    isMutation = defs[0]!.operation === OperationTypeNode.MUTATION\n  }\n\n  return isMutation\n}\n\nexport const analyzeDocument = (\n  document: RequestDocument,\n  excludeOperationName?: boolean,\n): { expression: string; operationName: string | undefined; isMutation: boolean } => {\n  const expression = typeof document === `string` ? document : print(document)\n\n  let isMutation = false\n  let operationName = undefined\n\n  if (excludeOperationName) {\n    return { expression, isMutation, operationName }\n  }\n\n  const docNode = tryCatch(() => (typeof document === `string` ? parse(document) : document))\n  if (docNode instanceof Error) {\n    return { expression, isMutation, operationName }\n  }\n\n  operationName = extractOperationName(docNode)\n  isMutation = extractIsMutation(docNode)\n\n  return { expression, operationName, isMutation }\n}\n", "import type { JsonSerializer } from './types.js'\n\nexport const defaultJsonSerializer: JsonSerializer = JSON\n", "import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js'\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js'\nimport { ClientError } from '../classes/ClientError.js'\nimport type { GraphQLExecutionResultSingle } from '../lib/graphql.js'\nimport {\n  cleanQuery,\n  isGraphQLContentType,\n  isRequestResultHaveErrors,\n  parseGraphQLExecutionResult,\n} from '../lib/graphql.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport type {\n  BatchVariables,\n  Fetch,\n  FetchOptions,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  RequestMiddleware,\n  Variables,\n} from './types.js'\n\ninterface Input {\n  url: string\n  /**\n   * The HTTP method to use for queries. Note that mutations are ALWAYS sent as POST requests ([per spec](https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md?rgh-link-date=2022-06-02T09%3A30%3A53Z)).\n   *\n   * @defaultValue `'POST'`\n   */\n  method?: HTTPMethodInput\n  fetch?: Fetch\n  fetchOptions: FetchOptions\n  headers?: HeadersInit\n  middleware?: RequestMiddleware\n  request:\n    | {\n      _tag: 'Single'\n      variables?: Variables\n      document: {\n        expression: string\n        isMutation: boolean\n        operationName?: string\n      }\n    }\n    | {\n      _tag: 'Batch'\n      query: string[]\n      operationName?: undefined\n      hasMutations: boolean\n      variables?: BatchVariables\n    }\n}\n\n// @ts-expect-error todo\nexport const runRequest = async (input: Input): Promise<ClientError | GraphQLClientResponse<any>> => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single`\n      ? input.request.document.isMutation\n        ? `POST`\n        : uppercase(input.method ?? `post`)\n      : input.request.hasMutations\n      ? `POST`\n      : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`,\n    },\n  }\n  const fetcher = createFetcher(config.method)\n  const fetchResponse = await fetcher(config)\n\n  if (!fetchResponse.ok) {\n    return new ClientError(\n      { status: fetchResponse.status, headers: fetchResponse.headers },\n      {\n        query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n        variables: input.request.variables,\n      },\n    )\n  }\n\n  const result = await parseResultFromResponse(\n    fetchResponse,\n    input.fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n  )\n\n  if (result instanceof Error) throw result // todo something better\n\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers,\n  }\n\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch`\n      ? { ...result.executionResults, ...clientResponseBase }\n      : {\n        ...result.executionResult,\n        ...clientResponseBase,\n      }\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables,\n    })\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult),\n      }\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config)),\n      }\n    default:\n      casesExhausted(result)\n  }\n}\n\nconst executionResultClientResponseFields = ($params: Input) => (executionResult: GraphQLExecutionResultSingle) => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined,\n  }\n}\n\nconst parseResultFromResponse = async (response: Response, jsonSerializer: JsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER)\n  const text = await response.text()\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text))\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text)\n  }\n}\n\nconst createFetcher = (method: 'GET' | 'POST') => async (params: Input) => {\n  const headers = new Headers(params.headers)\n  let searchParams: URLSearchParams | null = null\n  let body = undefined\n\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `))\n  }\n\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    body = $jsonSerializer.stringify(buildBody(params))\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON)\n    }\n  } else {\n    searchParams = buildQueryParams(params)\n  }\n\n  const init: RequestInit = { method, headers, body, ...params.fetchOptions }\n\n  let url = new URL(params.url)\n  let initResolved = init\n\n  if (params.middleware) {\n    const result = await Promise.resolve(\n      params.middleware({\n        ...init,\n        url: params.url,\n        operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n        variables: params.request.variables,\n      }),\n    )\n    const { url: urlNew, ...initNew } = result\n    url = new URL(urlNew)\n    initResolved = initNew\n  }\n\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value)\n    })\n  }\n\n  const $fetch = params.fetch ?? fetch\n  return await $fetch(url, initResolved)\n}\n\nconst buildBody = (params: Input) => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName,\n      }\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n\nconst buildQueryParams = (params: Input): URLSearchParams => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n  const searchParams = new URLSearchParams()\n  switch (params.request._tag) {\n    case `Single`: {\n      searchParams.append(`query`, cleanQuery(params.request.document.expression))\n      if (params.request.variables) {\n        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables))\n      }\n      if (params.request.document.operationName) {\n        searchParams.append(`operationName`, params.request.document.operationName)\n      }\n      return searchParams\n    }\n    case `Batch`: {\n      const variablesSerialized = params.request.variables?.map((v) => $jsonSerializer.stringify(v)) ?? []\n      const queriesCleaned = params.request.query.map(cleanQuery)\n      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n      searchParams.append(`query`, $jsonSerializer.stringify(payload))\n      return searchParams\n    }\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n", "import type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js'\nimport type { BatchRequestDocument, BatchRequestsOptions, BatchResult } from '../functions/batchRequests.js'\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js'\nimport { parseRawRequestArgs } from '../functions/rawRequest.js'\nimport { parseRequestArgs } from '../functions/request.js'\nimport { analyzeDocument } from '../helpers/analyzeDocument.js'\nimport { runRequest } from '../helpers/runRequest.js'\nimport type { RequestDocument, RequestOptions, VariablesAndRequestHeadersArgs } from '../helpers/types.js'\nimport {\n  type GraphQLClientResponse,\n  type RawRequestOptions,\n  type RequestConfig,\n  type Variables,\n} from '../helpers/types.js'\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(\n    private url: string,\n    public readonly requestConfig: RequestConfig = {},\n  ) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <\n    T,\n    $Variables extends Variables = Variables,\n  >(\n    ...args: RawRequestMethodArgs<$Variables>\n  ): Promise<GraphQLClientResponse<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<$Variables>(\n      queryOrOptions,\n      variables,\n      requestHeaders,\n    )\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const document = analyzeDocument(\n      rawRequestOptions.query,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document,\n        variables: rawRequestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: document.operationName,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  // dprint-ignore\n  async request<T, V extends Variables = Variables>(document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions:\n      | RequestDocument\n      | TypedDocumentNode<T, V>\n      | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(\n      documentOrOptions,\n      variables,\n      requestHeaders,\n    )\n\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const analyzedDocument = analyzeDocument(\n      requestOptions.document,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documents: BatchRequestDocument<$Variables>[],\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(options: BatchRequestsOptions<$Variables>): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documentsOrOptions:\n      | BatchRequestDocument<$Variables>[]\n      | BatchRequestsOptions<$Variables>,\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult> {\n    const batchRequestOptions = parseBatchRequestArgs<$Variables>(\n      documentsOrOptions,\n      requestHeaders,\n    )\n    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const analyzedDocuments = batchRequestOptions.documents.map(\n      ({ document }) => analyzeDocument(document, excludeOperationName),\n    )\n    const expressions = analyzedDocuments.map(({ expression }) => expression)\n    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation)\n    const variables = batchRequestOptions.documents.map(\n      ({ variables }) => variables,\n    )\n\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders),\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  setHeaders(headers: HeadersInit): this {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): this {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): this {\n    this.url = value\n    return this\n  }\n}\n\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(\n    query: string,\n    variables?: V,\n    requestHeaders?: HeadersInit,\n  ): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<\n    GraphQLClientResponse<T>\n  >\n}\n\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: HeadersInit]\n  | [RawRequestOptions<V>]\n", "import type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport { GraphQLClient } from '../classes/GraphQLClient.js'\nimport type { RequestDocument, RequestOptions, Variables, VariablesAndRequestHeadersArgs } from '../helpers/types.js'\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\n// REMARKS: In order to have autocomplete for options work make it the first overload. If not\n// then autocomplete will instead show the various methods for a string, which is not what we want.\n\n// dprint-ignore\nexport async function request<T, V extends Variables = Variables>(options: RequestExtendedOptions<V, T>): Promise<T>\n// dprint-ignore\nexport async function request<T, V extends Variables = Variables>(url: string, document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n// dprint-ignore\n// eslint-disable-next-line\nexport async function request<T, V extends Variables = Variables>(urlOrOptions: string | RequestExtendedOptions<V, T>, document?: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T> {\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\nexport const parseRequestArgs = <V extends Variables = Variables>(\n  documentOrOptions: RequestDocument | RequestOptions<V>,\n  variables?: V,\n  requestHeaders?: HeadersInit,\n): RequestOptions<V> => {\n  return (documentOrOptions as RequestOptions<V>).document\n    ? (documentOrOptions as RequestOptions<V>)\n    : ({\n      document: documentOrOptions as RequestDocument,\n      variables: variables,\n      requestHeaders: requestHeaders,\n      signal: undefined,\n    } as unknown as RequestOptions<V>)\n}\n\nexport type RequestExtendedOptions<V extends Variables = Variables, T = unknown> = {\n  url: string\n} & RequestOptions<V, T>\n\nexport const parseRequestExtendedArgs = <V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V>,\n  document?: RequestDocument,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): RequestExtendedOptions<V> => {\n  const [variables, requestHeaders] = variablesAndRequestHeaders\n  return typeof urlOrOptions === `string`\n    ? ({\n      url: urlOrOptions,\n      document: document as RequestDocument,\n      variables,\n      requestHeaders,\n      signal: undefined,\n    } as unknown as RequestExtendedOptions<V>)\n    : urlOrOptions\n}\n", "/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n * ```\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: unknown[]): string => {\n  return chunks.reduce(\n    (acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`,\n    ``,\n  )\n}\n", "import { ClientError } from '../legacy/classes/ClientError.js'\nimport {\n  type BatchRequestDocument,\n  type BatchRequestsExtendedOptions,\n  type BatchRequestsOptions,\n} from '../legacy/functions/batchRequests.js'\nimport type { RequestExtendedOptions } from '../legacy/functions/request.js'\nimport { request } from '../legacy/functions/request.js'\nimport type { GraphQLResponse, RequestMiddleware, ResponseMiddleware } from '../legacy/helpers/types.js'\nimport type { RawRequestOptions, RequestDocument, RequestOptions, Variables } from '../legacy/helpers/types.js'\nexport { GraphQLClient } from '../legacy/classes/GraphQLClient.js'\nexport { batchRequests } from '../legacy/functions/batchRequests.js'\nexport { gql } from '../legacy/functions/gql.js'\nexport { rawRequest } from '../legacy/functions/rawRequest.js'\nexport { analyzeDocument } from '../legacy/helpers/analyzeDocument.js'\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  GraphQLResponse,\n  type RawRequestOptions,\n  request,\n  type RequestDocument,\n  type RequestExtendedOptions,\n  RequestMiddleware,\n  type RequestOptions,\n  ResponseMiddleware,\n  type Variables,\n}\nexport default request\n\nexport { RequestInitExtended } from '../legacy/helpers/types.js'\n"],
  "mappings": "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",
  "names": ["request", "fetch", "variables"]
}
